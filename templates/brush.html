{% extends 'base.html' %}
{% block title %}Brush — Sentinel Labeler{% endblock %}

{% block head %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
<style>
  .map-wrap{height:calc(100vh - 110px)}
  #map{position:relative;height:100%;border-radius:14px;overflow:hidden;border:1px solid #1c2435;background:#0d1320}
  #maskCanvas,#cursorCanvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}
  #maskCanvas{z-index:1306}
  #cursorCanvas{z-index:1307}
  body.tool-brush #maskCanvas{pointer-events:auto}
  .leaflet-top,.leaflet-bottom,.leaflet-control-container{z-index:1400}
  .section .toolbar label{display:grid;gap:6px}
  .hud{display:grid;gap:8px;grid-template-columns:1fr auto;align-items:center;padding:8px;border:1px solid var(--line);background:var(--pane);border-radius:10px}
  .hud .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .chip{display:inline-flex;align-items:center;gap:6px;background:#101728;border:1px solid #1e2639;padding:4px 8px;border-radius:999px}
  .num{font-variant-numeric:tabular-nums}
  .kbd{background:#0f1626;border:1px solid #23304a;padding:0 6px;border-radius:6px;font-size:12px}
</style>
{% endblock %}

{% block main %}
<div class="map-wrap">
  <div id="map" class="map">
    <canvas id="maskCanvas"></canvas>
    <canvas id="cursorCanvas"></canvas>
  </div>
</div>
{% endblock %}

{% block left_panel %}
<div class="section">
  <div class="muted">Polygon Properties</div>
  <div class="toolbar" style="gap:10px;flex-wrap:wrap">
    <label style="flex:1 1 100%">UID
      <input id="polyUid" type="text" style="width:100%" readonly>
    </label>
    <label style="flex:1 1 100%">Fruit Type
      <input id="polyUsesFruit" type="text" style="width:100%">
    </label>
    <label style="flex:1 1 100%">Code
      <input id="polyCode" type="text" style="width:100%">
    </label>
    <label>Area (m²)
      <input id="polyAreaM2" type="number" step="0.01" readonly>
    </label>
    <label>Lat
      <input id="polyLat" type="number" step="0.000001" readonly>
    </label>
    <label>Lon
      <input id="polyLon" type="number" step="0.000001" readonly>
    </label>
    <label style="flex:1 1 100%">Label
      <select id="polyLabelSelect" style="width:100%">
        <option value="">—</option>
        <option value="veg">Vegetation</option>
        <option value="background">Background</option>
        <option value="__custom__">Custom…</option>
      </select>
      <div id="customLabelWrap" style="display:none;margin-top:6px">
        <input id="polyLabelCustom" type="text" placeholder="Custom label" style="width:100%">
      </div>
    </label>
    <label>Class ID
      <input id="polyClass" type="number" min="0" step="1" value="1">
    </label>
    <label>Color
      <input id="polyColor" type="color" value="#00ff00">
    </label>
    <div class="pill" style="gap:8px">
      <button id="applyPropsBtn" class="btn">Apply</button>
      <button id="savePolygonsBtn" class="btn primary">Save All</button>
    </div>
  </div>
</div>
{% endblock %}

{% block right_panel %}
{{ super() }}

<div class="section">
  <div class="hud">
    <div class="row">
      <span class="chip">Tile: <b id="hudTile">-</b></span>
      <span class="chip">Poly: <span id="hudIndex" class="num">0</span>/<span id="hudTotal" class="num">0</span></span>
      <span class="chip">Done: <span id="hudDone" class="num">0</span></span>
    </div>
    <div class="row">
      <button id="btnPrev" class="btn">Prev (P)</button>
      <button id="btnNext" class="btn">Next (N)</button>
    </div>
  </div>
</div>

<div class="section">
  <div class="muted">Mode</div>
  <div class="toolbar" style="gap:8px;flex-wrap:wrap">
    <button id="modePanBtn2" class="btn">Pan (V)</button>
    <button id="modeBrushBtn2" class="btn primary">Brush (B)</button>
  </div>
</div>

<div class="section">
  <div class="muted">Brush</div>
  <div class="toolbar" style="gap:10px;flex-wrap:wrap;align-items:center">
    <label>Size
      <input id="brushSize2" type="range" min="2" max="128" step="1" value="24" />
      <span id="brushSizeVal2">24 px</span>
    </label>
    <label style="display:flex;align-items:center;gap:6px">
      <input id="eraseChk2" type="checkbox" /> Erase (E)
    </label>
    <button id="clearMask2" class="btn">Clear</button>
    <button id="btnMarkDone" class="btn">Mark done (L)</button>
    <button id="savePng2" class="btn primary">Save PNG (S)</button>
  </div>
  <div class="muted" style="font-size:12px;margin-top:6px">
    Shortcuts: <span class="kbd">B</span>/<span class="kbd">V</span> • <span class="kbd">[</span>/<span class="kbd">]</span> size •
    <span class="kbd">E</span> erase • <span class="kbd">N</span>/<span class="kbd">P</span> next/prev • <span class="kbd">L</span> done • <span class="kbd">S</span> save
  </div>
</div>
{% endblock %}

{% block scripts %}
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js" defer></script>

<script src="{{ url_for('static', filename='js/brush/core.js') }}" defer></script>
<script src="{{ url_for('static', filename='js/brush/io.js') }}" defer></script>
<script src="{{ url_for('static', filename='js/brush/ui.js') }}" defer></script>

<script>
(function () {
  const log  = (...a) => console.debug('[BRUSH:UI]', ...a);
  const warn = (...a) => console.warn('[BRUSH:UI]', ...a);
  const err  = (...a) => console.error('[BRUSH:UI]', ...a);

  const $ = (id) => document.getElementById(id);

  async function wireOnceReady() {
    for (let i = 0; i < 200; i++) {
      if (window.BrushApp && BrushApp.map && BrushApp.maskCanvas) break;
      await new Promise(r => setTimeout(r, 50));
    }
    const App = window.BrushApp;
    if (!App) { err('BrushApp not found'); return; }

    const btnPan     = $('modePanBtn2');
    const btnBrush   = $('modeBrushBtn2');
    const rngSize    = $('brushSize2');
    const lblSize    = $('brushSizeVal2');
    const chkErase   = $('eraseChk2');
    const btnClear   = $('clearMask2');
    const btnSavePNG = $('savePng2');    
    const btnDone    = $('btnMarkDone');  
    btnPan?.addEventListener('click', () => {
      App.setMode('pan');
      btnPan?.classList.add('primary');
      btnBrush?.classList.remove('primary');
      log('mode->pan', App._diag?.());
    });
    btnBrush?.addEventListener('click', () => {
      App.setMode('brush');
      btnBrush?.classList.add('primary');
      btnPan?.classList.remove('primary');
      const pe = App.maskCanvas?.style.pointerEvents;
      log('mode->brush', { pointerEvents: pe }, App._diag?.());
      if (pe !== 'auto') {
        warn('maskCanvas not clickable; fixing...');
        try { App.maskCanvas.style.pointerEvents = 'auto'; } catch {}
      }
    });

    rngSize?.addEventListener('input', () => {
      const v = parseInt(rngSize.value || '24', 10);
      App.setBrushSize(v);
      if (lblSize) lblSize.textContent = `${v} px`;
      log('brush:size', v);
    });
    chkErase?.addEventListener('change', () => {
      App.setErase(!!chkErase.checked);
      log('brush:erase', !!chkErase.checked);
    });
    btnClear?.addEventListener('click', () => {
      App.clearMask?.();
      log('mask:cleared');
    });
    btnSavePNG?.addEventListener('click', async () => {
      try {
        await App.saveMask?.();
      } catch (e) {
        err('saveMask:error', e);
        alert('Save failed: ' + e);
      }
    });
    btnDone?.addEventListener('click', () => {
      log('mark:done (no-op here)');
    });
    window.addEventListener('keydown', (e) => {
      if (['INPUT','TEXTAREA','SELECT'].includes((e.target?.tagName || '').toUpperCase())) return;
      if (e.key === 'v' || e.key === 'V') {
        btnPan?.click();
      } else if (e.key === 'b' || e.key === 'B') {
        btnBrush?.click();
      } else if (e.key === '[') {
        const v = Math.max(2, (parseInt(rngSize?.value || '24', 10) - 1));
        if (rngSize) rngSize.value = String(v);
        rngSize?.dispatchEvent(new Event('input'));
      } else if (e.key === ']') {
        const v = Math.min(256, (parseInt(rngSize?.value || '24', 10) + 1));
        if (rngSize) rngSize.value = String(v);
        rngSize?.dispatchEvent(new Event('input'));
      } else if (e.key === 'e' || e.key === 'E') {
        if (chkErase) {
          chkErase.checked = !chkErase.checked;
          chkErase.dispatchEvent(new Event('change'));
        }
      }
    });

    if (rngSize) rngSize.dispatchEvent(new Event('input'));
    if (chkErase) chkErase.dispatchEvent(new Event('change'));

    log('UI wired ✔', App._diag?.());
  }

  document.addEventListener('DOMContentLoaded', wireOnceReady);
})();
</script>

<script>
  window.addEventListener('DOMContentLoaded', async () => {
    try {
      await window.BrushApp.init({
        mapId: 'map',
        maskId: 'maskCanvas',
        cursorId: 'cursorCanvas',
        enforceClip: true,
        overlayBoundsURL: '/api/s2_bounds_wgs84',
        overlayImageURL: '/api/output/rgb_quicklook.png'
      });

      window.BrushApp.ready = true;
      window.dispatchEvent(new Event('brush:ready'));

      if (window.BrushIO?.reloadPolygonsForScene) {
        await window.BrushIO.reloadPolygonsForScene();
      }
    } catch (e) {
      console.error('[BRUSH] init failed', e);
      if (window.BrushApp?.map) window.BrushApp.map.setView([30.0, 52.0], 12);
    }
  });

  (function () {
    const $ = (id) => document.getElementById(id);

    const elUid   = $('polyUid');
    const elUses  = $('polyUsesFruit');
    const elCode  = $('polyCode');
    const elArea  = $('polyAreaM2');
    const elLat   = $('polyLat');
    const elLon   = $('polyLon');
    const elLabelSel    = $('polyLabelSelect');
    const elCustomWrap  = $('customLabelWrap');
    const elLabelCustom = $('polyLabelCustom');
    const elClass = $('polyClass');
    const elColor = $('polyColor');
    const btnApply   = $('applyPropsBtn');
    const btnSaveAll = $('savePolygonsBtn');

    function showCustom() {
      elCustomWrap.style.display = (elLabelSel.value === '__custom__') ? 'block' : 'none';
    }
    elLabelSel?.addEventListener('change', showCustom);

    function computeAreaM2(layer) {
      try {
        const latlngs = layer.getLatLngs();
        const rings = (Array.isArray(latlngs[0]) && Array.isArray(latlngs[0][0])) ? latlngs : [latlngs];
        let sum = 0;
        for (const poly of rings) {
          const ring = (Array.isArray(poly) && Array.isArray(poly[0])) ? poly[0] : poly;
          sum += L.GeometryUtil.geodesicArea(ring);
        }
        return Math.max(0, sum);
      } catch { return 0; }
    }

    function populateForm(layer) {
      if (!layer) return;
      const p = layer._props || layer.feature?.properties || {};
      elUid.value  = p.uid || layer?.feature?.properties?.uid || String(layer?._leaflet_id || '');
      elUses.value = p.uses_fruit || '';
      elCode.value = p.code || '';
      const label = p.label || '';
      if (['veg','background',''].includes(label)) {
        elLabelSel.value = label;
        elLabelCustom.value = '';
      } else {
        elLabelSel.value = '__custom__';
        elLabelCustom.value = label;
      }
      showCustom();
      elClass.value = (p.class_id != null ? p.class_id : 1);
      elColor.value = p.color || '#00ff00';
      try {
        const ctr = layer.getBounds().getCenter();
        elLat.value = Number(ctr.lat.toFixed(6));
        elLon.value = Number(ctr.lng.toFixed(6));
      } catch {
        elLat.value = '';
        elLon.value = '';
      }
      elArea.value = Math.round(computeAreaM2(layer) * 100) / 100;
    }

    function applyForm(layer) {
      if (!layer) return;
      layer._props ||= {};
      const p = layer._props;
      p.uid        = elUid.value || p.uid || layer?.feature?.properties?.uid;
      p.uses_fruit = elUses.value || '';
      p.code       = elCode.value || '';
      p.label      = (elLabelSel.value === '__custom__') ? (elLabelCustom.value || '') : elLabelSel.value;
      p.class_id   = parseInt(elClass.value || '1', 10) || 1;
      p.color      = elColor.value || '#00ff00';
      try { layer.setStyle?.({ color: p.color, weight: 2 }); } catch {}
    }

    function wireAfterReady() {
      const App = window.BrushApp;
      const IO  = window.BrushIO;

      const prev = App.onLayerSelected;
      App.onLayerSelected = (layer) => {
        try { prev && prev(layer); } catch {}
        populateForm(layer);
      };
      if (App.selectedLayer) populateForm(App.selectedLayer);

      btnApply?.addEventListener('click', () => {
        const layer = IO?.current?.() || App?.selectedLayer;
        if (layer) applyForm(layer);
      });

      btnSaveAll?.addEventListener('click', async () => {
        const layer = IO?.current?.() || App?.selectedLayer;
        if (layer) applyForm(layer);
        const features = [];
        for (const ly of (App?.layers || [])) {
          const gj = ly.toGeoJSON();
          gj.properties = { ...(ly._props || {}) };
          features.push(gj);
        }
        const fc = { type:'FeatureCollection', features };
        const r = await fetch('/api/save_polygons', {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify(fc)
        });
        if (!r.ok) { alert('Save failed'); return; }
        alert('Polygons saved.');
      });
    }

    if (window.BrushApp?.ready) wireAfterReady();
    else window.addEventListener('brush:ready', wireAfterReady, { once:true });
  })();
</script>
{% endblock %}